---
title: "Lesson 1 - Fundamentals"
author: "Domingo Salerno"
date: "2023-12-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# RStudio Interface for Beginners

RStudio is an Integrated Development Environment (IDE) designed for R programming. It offers multiple panes and tools to enhance coding efficiency. Let's explore its interface.

## Panes in RStudio

### Source Pane
- This is where you write your R code in script files (.R or .Rmd).

### Console Pane
- Allows you to interactively run R code and view immediate output.

### Environment/History Pane
- Displays objects (variables, functions) in your current R session and a history of commands previously run.

### Files/Plots/Packages/Help Pane
- **Files**: Displays your current working directory's files.
- **Plots**: Shows plots generated by R.
- **Packages**: Lists installed packages and allows installation of new ones.
- **Help**: Provides documentation and help files for functions and packages.

## Working with RStudio

### Running Code

- To execute code in the source pane, select the code and click `Run` or use the shortcut `Ctrl + Enter`.
- Output appears in either the source or console pane, depending on your prefered settings.

### Managing Packages

- Use `install.packages("package_name")` to install packages.
- `library(package_name)` loads installed packages for use.
- `pacman::p_load(package_name1, package_name2)` installs any packages that have not already been installed and then loads them.

### Help and Documentation

- Access documentation using `?function_name` or `help(function_name)` to understand functions. This will be your bread and butter whenever you are learning to use a new function.

### Importing Data

- Use functions like `read.csv()`, `read.table()`, or `readr` package functions to import data.

### Creating Plots

- RStudio allows you to create various plots using functions like `plot()`, `ggplot()`, etc.

### RMarkdown

- RStudio supports RMarkdown (.Rmd) for creating dynamic documents with code, output, and text.

### Version Control

- RStudio integrates with version control systems like Git for project management.



# Introduction to R Markdown

R Markdown is a versatile tool that allows you to create dynamic documents integrating R code, text, and output in various formats (HTML, PDF, Word, etc.). They are also very useful for organizing your code, documenting your process, and navigating large files. Let's explore the basics.

## Structure of an R Markdown Document

An R Markdown document consists of three main types of content:

1. **Text**: Written using Markdown syntax, allowing for easy formatting of text.
2. **Code Chunks**: Blocks of executable R code enclosed by triple backticks (\`\`\`) with an `r` prefix for inline code.
3. **Output**: The results generated from the executed code chunks.

## Markdown Basics

### Headers

Headers are created by adding `#` symbols at the beginning of a line.

`# This is a top-level header
`## This is a second-level header
`### This is a third-level header

### Text Formatting

- *Italic*: `*italic*` or `_italic_`
- **Bold**: `**bold**` or `__bold__`
- `Code`: Enclosed within backticks (\`)

### Lists

#### Ordered List

1. Item 1
2. Item 2
   - Subitem A
   - Subitem B

#### Unordered List

- Apple
- Banana
  - Ripe
  - Unripe

### Code Chunks

R code chunks are enclosed by three backticks (\`\`\`) with the language specified:

```{r example chunk}
# This is an R code chunk
x <- 5
y <- 10
z <- x + y
z  # Output: 15
```

A useful shortcut for creating code chunks is `Ctrl + Alt + i`. Additionally, code chunks can be named for easier navigation.

Inline code can be inserted using the `r` syntax:

For example, \`r z\` will display the value of z, like this `r z`.

### Executing R Code

Execute R code chunks using the "Run Current Chunk" option or `Ctrl + Shift + Enter` in RStudio. You can also run a specific section of code in a chunk by highlighting it and using `Ctrl + Enter`.



# Data Structures in R

## Atomic Vectors

Atomic vectors are one-dimensional arrays that contain elements of the same data type (such as numeric, character, logical, etc.)

### Numeric Vectors

Numeric vectors store numerical values.

```{r}
# Create a numeric vector
numeric_vector <- c(3.5, 7.2, 9.1, 4.8)
numeric_vector
```

### Character Vectors

Character vectors store text data.

```{r}
# Create a character vector
character_vector <- c("apple", "banana", "pear")
character_vector
```

### Logical Vectors

Logical vectors store Boolean values (TRUE/FALSE).

```{r}
# Create a logical vector
logical_vector <- c(TRUE, FALSE, T, F)
logical_vector
```

### Accessing Elements

Elements within atomic vectors can be accessed using their indices:

```{r}
# Accessing elements in vectors
numeric_vector[2]     # Access the second element of a numeric vector
character_vector[3]   # Access the third element of a character vector
logical_vector[c(T, F, F, T)]  # Access elements based on logical indexing
```

### Vector Operations

Atomic vectors support various operations like arithmetic, logical, and comparison operations:

```{r}
# Vector operations
numeric_vector * 2   # Multiply each element in the numeric vector by 2
character_vector == "banana"  # Check equality with a specific value
logical_vector & TRUE  # Perform logical AND operation with TRUE
```

### Practical Use Cases:

- Data Storage: Storing homogeneous data elements like names, ages, or measurements.
- Vectorized Operations: Performing operations on entire vectors efficiently without loops.
- Data Filtering: Using logical indexing to filter elements based on conditions.

Understanding atomic vectors and their properties is crucial in R programming as they form the basis for various data manipulation tasks and are frequently used in statistical analysis, data exploration, and visualization. Their simplicity and efficiency in handling homogeneous data make them a fundamental structure in R.

## Lists

Lists are ordered collections of elements that can be of different types (vectors, matrices, other lists, etc.) within a single data structure. This versatility makes lists an essential tool for storing heterogeneous data.

### Creating Lists

```{r}
# Create a list with different types of elements
my_list <- list(
  name = "John",
  age = 25,
  scores = c(85, 92, 78),
  is_student = TRUE
)
my_list
```

### Accessing List Elements

Elements within a list can be accessed using their indices or names:

```{r}
# Accessing list elements
my_list[[1]]  # Accessing by index
my_list[[3]]
my_list[[3]][2]
my_list$name   # Accessing by name
```

### Nested Lists

Lists can also contain other lists as elements.

```{r}
# Create a nested list
nested_list <- list(
  list_item1 = list(1, 2, 3),
  list_item2 = list("a", "b", "c")
)
nested_list
```

### Manipulating Lists

Lists in R can be modified by adding, removing, or altering elements:

- Adding Elements: Use the $ operator or [[ ]] to add new elements to a list.
- Removing Elements: Use NULL or list(-index) to remove elements.
- Updating Elements: Change values by assigning new values to elements.

```{r}
# Adding a new element
my_list$address <- "123 Main St"

# Removing an element
my_list[[4]] <- NULL  # Remove the fourth element
my_list <- my_list[-2]

# Updating an element
my_list$name <- "Alice"  # Update the 'name' element
```

### Practical Use Cases

Lists are handy for storing complex data structures, such as:

- Mixed Data Types: Storing various types of data within a single object.
- Hierarchical Data: Representing hierarchical or nested structures.
- Results from Functions: Collecting results from different analyses or functions.

Understanding lists and their flexibility is crucial as they are frequently used in handling diverse and complex data structures in R. Their ability to store heterogeneous data elements in a structured way makes them a powerful tool for data manipulation and analysis.

## Data Frames in R

Data frames are two-dimensional tabular data structures in R used to store datasets in a tabular form. They resemble a spreadsheet with rows representing observations and columns representing variables.

### Creating Data Frames

Data frames can be created using the `data.frame()` function in R:

```{r}
# Creating a data frame
my_data <- data.frame(
  Name = c("Alice", "Bob", "Charlie"),
  Age = c(25, 30, 28),
  Grade = c("A", "B", "C"),
  Passed = c(TRUE, TRUE, FALSE)
)
my_data
```

### Properties of Data Frames

- Tabular Structure: Data frames have rows and columns.
- Columns with Different Types: Each column can have a different data type.
- Equal Length Columns: All columns must have the same length.

### Accessing Data Frames

#### Column Selection

Columns in a data frame can be accessed using the $ operator or [[ ]]:

```{r}
# Accessing columns in a data frame
my_data$Name        # Access the 'Name' column
my_data[["Age"]]    # Access the 'Age' column
my_data[["Age"]][1] # Access the first value in the 'Age' column
```

#### Row Selection

Rows can be accessed using indexing or logical conditions:

```{r}
# Accessing rows in a data frame
my_data[2, ]         # Access the second row
my_data[my_data$Age > 25, ]  # Access rows based on condition

# Accessing a specific cell (my_data[row_number, column_number])
my_data[2, 1]        # Access the second value of the first column
```

### Manipulating Data Frames

#### Adding Columns

New columns can be added to a data frame:

```{r}
# Adding a new column
my_data$City <- c("New York", "San Francisco", "Los Angeles")
```

#### Removing Columns

Columns can be removed using NULL or indexing:

```{r}
# Removing a column
my_data$City <- NULL  # Remove the 'City' column
my_data <- my_data[-4] # Remove the fourth column
```

### Practical Use Cases

- Data Storage: Storing structured data with observations and variables.
- Data Exploration: Analyzing and exploring datasets with multiple variables.
- Data Manipulation: Performing operations like subsetting, merging, and transforming data.

Data frames are versatile and widely used in data analysis, statistics, and machine learning tasks in R. Their ability to handle heterogeneous data and provide efficient ways to manipulate and analyze datasets makes them a fundamental data structure for data scientists and analysts.



# Exercises

## Exercise 1: Vectors

1. Create a Character Vector: Store the names of five different languages.
2. Create a Numeric Vector: Represent the number of speakers for each language.
3. Create a Logical Vector: Indicate whether each language has official status (TRUE/FALSE).

## Exercise 2: Lists

1. Create a List of Linguistic Features: For each language, create a sublist containing Phonology, Morphology, and Syntax.
2. Create a List of Language Families: Sublists should contain languages grouped by their linguistic families.

## Exercise 3: Data Frames

1. Create a Lexicon Data Frame: Columns should include:
  - Word: Character vector of words in different languages.
  - Language: Character vector denoting the language each word belongs to.
  - PartOfSpeech: Character vector indicating the part of speech of each word.
  - Frequency: Numeric vector representing the frequency of each word.
2. Create a LanguageInfo Data Frame: Columns should include:
  - Language: Character vector of languages.
  - Country: Character vector denoting the country where the language is spoken.
  - Speakers: Numeric vector indicating the number of speakers.
  
## Exercise 4: Accessing Elements

1. Access a Specific Language from the Character Vector.
2. Access a Sublist of Linguistic Features for a Language from the List.
3. Access a Specific Word and Its Frequency from the Lexicon Data Frame.
4. Access the Number of Speakers for a Specific Language from the LanguageInfo Data Frame.

## Exercise 5: Manipulating Data Structures

1. Update the Number of Speakers for a Language in the LanguageInfo Data Frame.
2. Add a New Language and Its Information to the Character Vector, List, and Data Frames.
3. Remove a Language from the LanguageInfo Data Frame.

